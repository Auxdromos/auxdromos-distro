image: maven:3.9.9-amazoncorretto-17

stages:
  - prepare
  - build
  - test
  - artifact_upload_s3
  - check_version
  - deploy_sit

include:
  - template: Security/Dependency-Scanning.gitlab-ci.yml

variables:
  S3_BUCKET_NAME: "auxdromos-artifacts-unique"
  AWS_DEFAULT_REGION: "us-east-1"
  MODULES_TO_REFRESH: "rdbms gateway backend idp"

extract_module_name:
  stage: prepare
  script: |
    echo "Estrazione del MODULE_NAME dal pom.xml..."
    export MODULE_NAME=$(grep "<artifactId>" pom.xml | head -1 | sed 's/[<>]/|/g' | cut -d'|' -f3)
    if [ -z "$MODULE_NAME" ]; then echo "Errore: impossibile estrarre MODULE_NAME dal pom.xml"; exit 1; fi
    echo "MODULE_NAME estratto: $MODULE_NAME"
    echo "MODULE_NAME=$MODULE_NAME" >> module_name.env
  artifacts:
    reports:
      dotenv: module_name.env

build:
  stage: build
  dependencies:
    - extract_module_name
  script:
    - echo "Build del modulo $MODULE_NAME..."
    - mvn clean package -Psit -DskipTests
  artifacts:
    paths:
      - target/*.jar

test:
  stage: test
  dependencies:
    - extract_module_name
  script:
    - echo "Test del modulo $MODULE_NAME..."
    - mvn test

artifact_upload_s3:
  stage: artifact_upload_s3
  image:
    name: amazon/aws-cli:latest
    entrypoint: [""]
  dependencies:
    - build
    - extract_module_name
  script:
    - set -x
    - VERSION=$(grep "<version>" pom.xml | head -1 | sed 's/[<>]/|/g' | cut -d'|' -f3)
    - echo "Versione rilevata - $VERSION - Modulo $MODULE_NAME - $MODULE_NAME-$VERSION.jar"
    - echo "Contenuto della directory target:"
    - ls -la target
    # Cerca il file jar usando un pattern che includa eventuali suffissi
    - JAR_FILE=$(ls target/$MODULE_NAME-$VERSION*.jar)
    - echo "File jar individuato $JAR_FILE"
    - aws s3 cp $JAR_FILE s3://$S3_BUCKET_NAME/$MODULE_NAME/ --region $AWS_DEFAULT_REGION
    - |
      files_to_delete=$(aws s3 ls s3://$S3_BUCKET_NAME/$MODULE_NAME/ --region $AWS_DEFAULT_REGION | head -n -5 | awk '{print $4}')
      if [ -n "$files_to_delete" ]; then
        for file in $files_to_delete; do
          echo "Eliminazione del file: $file"
          aws s3 rm s3://$S3_BUCKET_NAME/$MODULE_NAME/$file --region $AWS_DEFAULT_REGION
        done
      else
        echo "Meno di 5 versioni presenti, nessun file eliminato"
      fi
    - exit 0
  only:
    - develop
  environment:
    name: sit

check_version:
  stage: check_version
  dependencies:
    - extract_module_name
  image: amazon/aws-cli:latest
  only:
    - main
  script:
    - |
      set -x
      NEW_VERSION=$(grep "<version>" pom.xml | head -1 | sed 's/[<>]/|/g' | cut -d'|' -f3)
      echo "Nuova versione rilevata: $NEW_VERSION"
      
      # Controlla se la versione contiene "SNAPSHOT"
      if [[ "$NEW_VERSION" == *"SNAPSHOT"* ]]; then
        echo "Errore: la versione $NEW_VERSION è una versione SNAPSHOT e non può essere rilasciata sul ramo main"
        exit 1
      fi
      
      CURRENT_FILE=$(aws s3 ls s3://$S3_BUCKET_NAME/$MODULE_NAME/ --region $AWS_DEFAULT_REGION | awk '{print $4}' | sort -V | tail -n1)
      
      if [ -n "$CURRENT_FILE" ]; then
        CURRENT_VERSION=$(echo "$CURRENT_FILE" | sed "s/$MODULE_NAME-//; s/\.jar//")
        echo "Versione attualmente presente su S3: $CURRENT_VERSION"
      else
        echo "Nessuna versione presente su S3."
      fi
      
      if [ -n "$CURRENT_FILE" ]; then
        if [ "$CURRENT_VERSION" = "$NEW_VERSION" ]; then
          echo "Errore: la nuova versione ($NEW_VERSION) è la stessa di quella presente ($CURRENT_VERSION)"
          exit 1
        fi
      
        SORTED=$(printf '%s\n' "$CURRENT_VERSION" "$NEW_VERSION" | sort -V | head -n1)
        if [ "$SORTED" = "$NEW_VERSION" ]; then
          echo "Errore: la nuova versione ($NEW_VERSION) non è successiva a quella presente ($CURRENT_VERSION)"
          exit 1
        fi
      fi
      
      aws s3 ls s3://$S3_BUCKET_NAME/$MODULE_NAME/$MODULE_NAME-$NEW_VERSION.jar --region $AWS_DEFAULT_REGION
      if [ $? -eq 0 ]; then
        echo "Errore: la versione $NEW_VERSION è già presente su S3."
        exit 1
      else
        echo "La versione $NEW_VERSION non è presente su S3, procedo."
      fi

deploy_sit:
  stage: deploy_sit
  script:
    - |
      # Carica le variabili d'ambiente necessarie
      source "env/deploy.env"
      
      # Verifica se Keycloak è in esecuzione
      KEYCLOAK_RUNNING=$(ssh $EC2_USER@$EC2_HOST "docker ps | grep -q 'keycloak-auxdromos' && echo 'true' || echo 'false'")
      
      # Leggi il nome del modulo corrente
      CURRENT_MODULE="$MODULE_NAME"
      
      if [ "$KEYCLOAK_RUNNING" = "false" ]; then
        echo "Keycloak non è attivo. Verrà deployato prima di procedere..."
        ./deploy_module.sh "$CURRENT_MODULE"
      else
        # Keycloak è già attivo, facciamo il deploy solo del modulo corrente
        echo "Deploy del modulo $CURRENT_MODULE..."
        ./deploy_module.sh "$CURRENT_MODULE"
      fi
  dependencies:
    - extract_module_name
  only:
    - main
  environment:
    name: sit

refresh-services:
  stage: refresh
  before_script:
    - mkdir -p ~/.ssh
    - echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - ssh-keyscan -H $EC2_HOST >> ~/.ssh/known_hosts
  script:
    - echo "🔄 Avvio refresh delle configurazioni su AWS..."
    - |
      ssh -i ~/.ssh/id_rsa $EC2_USER@$EC2_HOST << 'EOF'
        for service in $MODULES_TO_REFRESH; do
          echo "🔹 Tentativo di refresh per $service su AWS..."
          success=false
          for i in {1..3}; do
            if curl -X POST http://$service:8080/config/refresh --max-time 5 --silent --fail; then
              echo "✅ Refresh riuscito per $service su AWS!"
              success=true
              break
            else
              echo "⚠ Tentativo $i fallito per $service... Riprovo in 5 secondi"
              sleep 5
            fi
          done
          if [ "$success" = false ]; then
            echo "❌ Errore critico: il servizio $service su AWS non ha risposto dopo 3 tentativi!"
            exit 1
          fi
        done
      EOF
  only:
    - main
  retry: 2