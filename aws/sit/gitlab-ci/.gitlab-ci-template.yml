image: maven:3.9.9-amazoncorretto-17

stages:
  - prepare
  - check_version
  - build
  - test
  - package
  - docker
  - upload_to_s3
  - tag_latest
  - cleanup
  - deploy_sit

extract_module_info:
  stage: prepare
  script:
    - echo "Estrazione delle informazioni del modulo di distribuzione..."
    # Rimuovi apk add e usa i comandi che sono già disponibili in maven:amazoncorretto
    # grep e sed sono già installati nell'immagine Maven
    - |
      if [ -f "pom.xml" ]; then
        export MODULE_NAME=$(grep "<artifactId>" pom.xml | head -1 | sed 's/[<>]/|/g' | cut -d'|' -f3)
        export VERSION=$(grep "<version>" pom.xml | head -1 | sed 's/[<>]/|/g' | cut -d'|' -f3)
      else
        # Se non c'è un pom.xml, assegna un nome di default e una versione basata sullo short SHA
        export MODULE_NAME="auxdromos-distro"
        export VERSION="1.0.0-${CI_COMMIT_SHORT_SHA}"
      fi

    - echo "MODULE_NAME=$MODULE_NAME" >> module_info.env
    - echo "VERSION=$VERSION" >> module_info.env
    - echo "Modulo $MODULE_NAME, Versione $VERSION"
    # Aggiungi un comando per verificare che il file esista e mostrarne il contenuto
    - ls -la module_info.env
    - cat module_info.env
  artifacts:
    reports:
      dotenv: module_info.env

check_version:
  stage: check_version
  dependencies:
    - extract_module_info
  image:
    name: amazon/aws-cli:latest
    entrypoint: [ "" ]
  script: |
    set -e
    set -o pipefail

    echo "Verifica della versione..."

    # Carichiamo VERSION dal file .env creato prima
    if [ -f module_info.env ]; then
      . module_info.env
    fi

    # Per il branch main
    if [[ "$CI_COMMIT_REF_NAME" == "main" ]]; then
      # Vietiamo l'uso di SNAPSHOT in main
      if [[ "$VERSION" == *"SNAPSHOT"* ]]; then
        echo "Errore: Versione '$VERSION' non valida in 'main' (SNAPSHOT non consentito)."
        exit 1
      fi
    
      # Su main, controlliamo solo ECR (perché S3 può già esistere da develop)
      if aws ecr describe-images --repository-name auxdromos-$MODULE_NAME --image-ids imageTag=$VERSION --region $AWS_DEFAULT_REGION > /dev/null 2>&1; then
        echo "Errore: La versione '$VERSION' è già presente su ECR."
        exit 1
      fi
    
      echo "Versione valida per main. Procedo..."
    else
      # Per develop e altri branch, controlliamo solo S3 sotto un path specifico per develop
      DEVELOP_PATH="develop/${MODULE_NAME}/${VERSION}/"
      FOUND=$(aws s3 ls "s3://${S3_BUCKET_NAME}/${DEVELOP_PATH}" 2>/dev/null | wc -l || echo 0)
      echo "DEBUG FOUND = $FOUND per path ${DEVELOP_PATH}"

      if [[ "$FOUND" -gt 0 ]]; then
        echo "Versione già presente su S3 in develop. Interrompo la pipeline."
        exit 1
      else
        echo "Versione non presente su S3 in develop. Procedo..."
      fi
    fi

build:
  stage: build
  image: maven:3.9.9-amazoncorretto-17  # Usa l'immagine Maven appropriata
  dependencies:
    - extract_module_info
    - check_version
  script:
    - if [ -f module_info.env ]; then . module_info.env; fi
    - echo "Build del modulo $MODULE_NAME..."
    - mvn clean package -Psit -DskipTests
    # Crea un file manifest che descrive questa build
    - |
      cat > target/build-info.json <<EOF
      {
        "moduleName": "$MODULE_NAME",
        "version": "$VERSION",
        "buildDate": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
        "branch": "$CI_COMMIT_REF_NAME",
        "commitHash": "$CI_COMMIT_SHA"
      }
      EOF
  artifacts:
    paths:
      - target/*.jar
      - target/distribution/
      - target/build-info.json

test:
  stage: test
  image: maven:3.9.9-amazoncorretto-17
  dependencies:
    - extract_module_info
    - build
  script:
    - if [ -f module_info.env ]; then . module_info.env; fi
    - echo "Test del modulo $MODULE_NAME..."
    - mvn test

package_configs:
  stage: package
  image: alpine:latest  # Usa Alpine Linux (molto leggera)
  script:
    - set -x
    - if [ -f module_info.env ]; then . module_info.env; fi
    - echo "Creazione pacchetto di configurazione $MODULE_NAME versione $VERSION..."

    # Installa zip in Alpine
    - apk add --no-cache zip

    # Il resto del tuo script
    - mkdir -p dist
    - |
      FILES_TO_ZIP=""
      for DIR in aws docker scripts env; do
        if [ -d "$DIR" ]; then
          FILES_TO_ZIP="$FILES_TO_ZIP $DIR/"
          echo "Aggiungo directory $DIR al ZIP"
        fi
      done
      
      for EXT in yml yaml properties; do
        if ls *.$EXT 1>/dev/null 2>&1; then
          FILES_TO_ZIP="$FILES_TO_ZIP *.$EXT"
          echo "Aggiungo file *.$EXT al ZIP"
        fi
      done
      
      if [ -n "$FILES_TO_ZIP" ]; then
        echo "Creazione ZIP con: $FILES_TO_ZIP"
        zip -r "dist/$MODULE_NAME-$VERSION.zip" $FILES_TO_ZIP
      else
        echo "AVVISO: Nessun file trovato da includere nel ZIP"
        touch empty.txt
        zip -r "dist/$MODULE_NAME-$VERSION.zip" empty.txt
        rm empty.txt
      fi

    - echo "{\"moduleName\":\"$MODULE_NAME\",\"version\":\"$VERSION\",\"buildDate\":\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",\"branch\":\"$CI_COMMIT_REF_NAME\",\"commitHash\":\"$CI_COMMIT_SHA\"}" > dist/manifest.json
  dependencies:
    - extract_module_info
    - check_version
  artifacts:
    paths:
      - dist/

build_docker:
  stage: docker
  image: docker:latest
  services:
    - docker:dind
  dependencies:
    - extract_module_info
    - build
  before_script:
    - apk add --no-cache aws-cli curl
  script:
    - if [ -f module_info.env ]; then . module_info.env; fi
    - echo "Verificando presenza Dockerfile per $MODULE_NAME..."
    - |
      if [ -f "Dockerfile" ]; then
        echo "Dockerfile trovato per $MODULE_NAME, procedo con build e push"
      
        # Autenticazione con AWS ECR
        aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com
      
        # Costruzione dell'immagine Docker
        docker build -t auxdromos-$MODULE_NAME:$VERSION .
      
        # Tagging dell'immagine
        docker tag auxdromos-$MODULE_NAME:$VERSION $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/auxdromos-$MODULE_NAME:$VERSION
      
        # Push dell'immagine su ECR
        docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/auxdromos-$MODULE_NAME:$VERSION
      
        echo "Immagine Docker caricata con successo: auxdromos-$MODULE_NAME:$VERSION"
      else
        echo "Dockerfile non trovato per $MODULE_NAME, salto build e push Docker"
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == "main"  # Esegui solo sul branch main
      when: on_success

upload_to_s3:
  stage: upload_to_s3
  image:
    name: amazon/aws-cli:latest
    entrypoint: [ "" ]
  dependencies:
    - extract_module_info
    - build
  script:
    - if [ -f module_info.env ]; then . module_info.env; fi

    # Determina il path S3 in base al branch
    - |
      if [[ "$CI_COMMIT_REF_NAME" == "main" ]]; then
        S3_PATH="${MODULE_NAME}/${VERSION}/"
      else
        S3_PATH="develop/${MODULE_NAME}/${VERSION}/"
      fi

    - echo "Upload su S3 per $MODULE_NAME versione $VERSION nel path $S3_PATH"

    # Upload dei file JAR
    - |
      for jar in target/*.jar; do
        if [ -f "$jar" ]; then
          jar_filename=$(basename "$jar")
          echo "Uploading $jar_filename..."
          aws s3 cp "$jar" "s3://${S3_BUCKET_NAME}/${S3_PATH}${jar_filename}"
        fi
      done

    # Upload dei file di distribuzione
    - |
      if [ -d "target/distribution/" ]; then
        echo "Uploading distribution files..."
        aws s3 cp target/distribution/ "s3://${S3_BUCKET_NAME}/${S3_PATH}distribution/" --recursive
      fi

    # Upload del file build-info.json
    - |
      if [ -f "target/build-info.json" ]; then
        echo "Uploading build info..."
        aws s3 cp target/build-info.json "s3://${S3_BUCKET_NAME}/${S3_PATH}build-info.json"
      fi

tag_latest:
  stage: tag_latest
  image:
    name: amazon/aws-cli:latest
    entrypoint: [ "" ]
  dependencies:
    - extract_module_info
    - upload_to_s3
  script:
    - if [ -f module_info.env ]; then . module_info.env; fi

    # Determina il path S3 in base al branch
    - |
      if [[ "$CI_COMMIT_REF_NAME" == "main" ]]; then
        S3_PATH="${MODULE_NAME}/"
        LATEST_PATH="${MODULE_NAME}/latest.json"
      else
        S3_PATH="develop/${MODULE_NAME}/"
        LATEST_PATH="develop/${MODULE_NAME}/latest.json"
      fi

    # Crea un file JSON con i dettagli dell'ultima versione
    - |
      cat > latest.json <<EOF
      {
        "moduleName": "$MODULE_NAME",
        "latestVersion": "$VERSION",
        "updateDate": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
        "branch": "$CI_COMMIT_REF_NAME",
        "commitHash": "$CI_COMMIT_SHA"
      }
      EOF

    - echo "Tagging della versione $VERSION come 'latest' per $MODULE_NAME nel path $S3_PATH"
    - aws s3 cp latest.json "s3://${S3_BUCKET_NAME}/${LATEST_PATH}"

deploy_sit:
  stage: deploy_sit
  image:
    name: amazon/aws-cli:latest
    entrypoint: [""]
  dependencies:
    - extract_module_info
    - upload_to_s3
  script:
    - if [ -f module_info.env ]; then . module_info.env; fi
    - echo "Deployment dell'applicazione $MODULE_NAME versione $VERSION in ambiente SIT..."
    - |
      cat > deploy_script.sh << 'EOF'
      #!/bin/bash
      set -e
      
      # Assicuriamoci che le directory necessarie esistano
      mkdir -p /app/distro/artifacts/aws/sit/env
      mkdir -p /app/distro/artifacts/aws/sit/script
      
      # Scarica gli artifact dalla versione corrente in S3 nella directory artifacts
      cd /app/distro && \
      aws s3 cp s3://$S3_BUCKET_NAME/$MODULE_NAME/$VERSION/ ./artifacts/ --recursive
      
      # Aggiorna il file di versione corrente
      echo "$VERSION" > current-version.txt
      
      # Rendi eseguibili gli script
      chmod +x ./artifacts/aws/sit/script/*.sh
      
      # Verifica che deploy.env esista
      if [ ! -f "/app/distro/artifacts/aws/sit/env/deploy.env" ]; then
        echo "ERRORE: File deploy.env non trovato in /app/distro/artifacts/aws/sit/env"
        echo "Il file deploy.env deve esistere prima di eseguire il deployment."
        echo "Assicurati che il file sia presente nell'istanza o incluso negli artifact del modulo distro."
        exit 1
      fi
      
      # Se NON è il modulo distro, esegui il deploy_module.sh
      if [ "$MODULE_NAME" != "distro" ] && [ "$MODULE_NAME" != "auxdromos-distro" ]; then
        echo "Esecuzione di deploy_module.sh per il modulo $MODULE_NAME..."
        cd /app/distro/artifacts/aws/sit/script && \
        ./deploy_module.sh $MODULE_NAME && \
        echo "Deployment di $MODULE_NAME v$VERSION completato con successo"
      else
        echo "Modulo distro aggiornato alla versione $VERSION. Gli script sono pronti per essere eseguiti manualmente o dai moduli specifici."
      fi
      EOF
    - sed -i "s/\$S3_BUCKET_NAME/${S3_BUCKET_NAME}/g" deploy_script.sh
    - sed -i "s/\$MODULE_NAME/${MODULE_NAME}/g" deploy_script.sh
    - sed -i "s/\$VERSION/${VERSION}/g" deploy_script.sh
    - aws s3 cp deploy_script.sh s3://${S3_BUCKET_NAME}/scripts/deploy_${MODULE_NAME}_${VERSION}.sh
    - COMMAND_ID=$(aws ssm send-command --document-name "AWS-RunShellScript" --instance-ids "$INSTANCE_ID" --parameters commands="$DEPLOY_SCRIPT" --output text --query "Command.CommandId")
    - echo "Deployment avviato con CommandID: $COMMAND_ID"
    - |
      echo "Monitoraggio dell'esecuzione del comando..."
      STATUS="Pending"
      
      while [[ "$STATUS" == "Pending" || "$STATUS" == "InProgress" ]]; do
        sleep 5
        CMD_OUTPUT=$(aws ssm list-command-invocations --command-id "$COMMAND_ID" --details --output json)
        STATUS=$(echo "$CMD_OUTPUT" | grep -o '"Status": "[^"]*"' | cut -d'"' -f4)
        echo "Stato corrente: $STATUS"
      
        # Mostra log dell'esecuzione se disponibili
        if [[ $(echo "$CMD_OUTPUT" | grep -o '"StandardOutputContent": "[^"]*"' | wc -l) -gt 0 ]]; then
          echo "--- LOG OUTPUT ---"
          echo "$CMD_OUTPUT" | grep -o '"StandardOutputContent": "[^"]*"' | cut -d'"' -f4 | sed 's/\\n/\n/g'
          echo "-----------------"
        fi
      
        # Mostra anche gli errori se ce ne sono
        if [[ $(echo "$CMD_OUTPUT" | grep -o '"StandardErrorContent": "[^"]*"' | wc -l) -gt 0 ]]; then
          echo "--- ERROR LOG ---"
          echo "$CMD_OUTPUT" | grep -o '"StandardErrorContent": "[^"]*"' | cut -d'"' -f4 | sed 's/\\n/\n/g'
          echo "----------------"
        fi
      done
      
      if [[ "$STATUS" == "Success" ]]; then
        echo "✅ Deployment completato con successo!"
        exit 0
      else
        echo "❌ Deployment fallito con stato: $STATUS"
        exit 1
      fi
  environment:
    name: sit
    url: https://sit.auxdromos.com
  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH =~ /^release\/.*$/
      when: manual
    - when: never

cleanup_s3:
  stage: cleanup
  image:
    name: amazon/aws-cli:latest
    entrypoint: [ "" ]
  dependencies:
    - extract_module_info
  script:
    - if [ -f module_info.env ]; then . module_info.env; fi

    # Determina il path S3 in base al branch
    - |
      if [[ "$CI_COMMIT_REF_NAME" == "main" ]]; then
        S3_BASE_PATH="${MODULE_NAME}/"
      else
        S3_BASE_PATH="develop/${MODULE_NAME}/"
      fi

    - echo "Pulizia S3 per $S3_BASE_PATH, mantenendo solo le ultime 5 versioni..."
    - |
      # Ottieni lista di tutte le versioni, filtrando solo le directory che terminano con /
      echo "Elenco contenuti in s3://${S3_BUCKET_NAME}/${S3_BASE_PATH}"
      aws s3 ls "s3://${S3_BUCKET_NAME}/${S3_BASE_PATH}"
      
      # Filtra solo le directory di versione (terminano con /)
      # e che contengono pattern numerico x.y (versione semantica)
      VERSIONS=$(aws s3 ls "s3://${S3_BUCKET_NAME}/${S3_BASE_PATH}" | grep '/$' | grep -E '[0-9]+\.[0-9]+' | awk '{print $2}' | sed 's#/$##' | sort -t. -k1,1n -k2,2n -k3,3n)
      
      echo "Versioni trovate dopo il filtraggio:"
      echo "$VERSIONS"
      
      VERSION_COUNT=$(echo "$VERSIONS" | grep -v '^$' | wc -l)
      echo "Numero di versioni valide: $VERSION_COUNT"
      
      # Se ci sono più di 5 versioni, rimuovi le più vecchie
      if [[ $VERSION_COUNT -gt 5 ]]; then
        TO_DELETE=$(($VERSION_COUNT - 5))
        echo "Rimozione delle $TO_DELETE versioni più vecchie..."
      
        # Ottieni le N versioni più vecchie da rimuovere
        VERSIONS_TO_DELETE=$(echo "$VERSIONS" | head -n $TO_DELETE)
      
        echo "Versioni da eliminare:"
        echo "$VERSIONS_TO_DELETE"
      
        for OLD_VERSION in $VERSIONS_TO_DELETE; do
          if [[ -n "$OLD_VERSION" ]]; then  # Verifica che non sia vuoto
            echo "Rimozione versione $OLD_VERSION da S3..."
            aws s3 rm "s3://${S3_BUCKET_NAME}/${S3_BASE_PATH}${OLD_VERSION}/" --recursive
          fi
        done
      else
        echo "Ci sono $VERSION_COUNT versioni, non è necessaria alcuna pulizia (< 6)."
      fi