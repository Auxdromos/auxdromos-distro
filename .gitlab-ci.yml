include:
  - template: Security/Dependency-Scanning.gitlab-ci.yml

image: alpine:latest

stages:
  - prepare
  - check_version
  - test
  - package
  - upload
  - deploy_configs

extract_module_info:
  stage: prepare
  script:
    - echo "Estrazione delle informazioni del modulo di distribuzione..."
    - apk add --no-cache grep sed
    - |
      if [ -f "pom.xml" ]; then
        export MODULE_NAME=$(grep "<artifactId>" pom.xml | head -1 | sed 's/[<>]/|/g' | cut -d'|' -f3)
        export VERSION=$(grep "<version>" pom.xml | head -1 | sed 's/[<>]/|/g' | cut -d'|' -f3)
      else
        # Se non c'è un pom.xml, assegna un nome di default e una versione basata sullo short SHA
        export MODULE_NAME="auxdromos-distro"
        export VERSION="1.0.0-${CI_COMMIT_SHORT_SHA}"
      fi

    - echo "MODULE_NAME=$MODULE_NAME" >> module_info.env
    - echo "VERSION=$VERSION" >> module_info.env
    - echo "Modulo $MODULE_NAME, Versione $VERSION"
  artifacts:
    reports:
      dotenv: module_info.env

check_version:
  stage: check_version
  image:
    name: amazon/aws-cli:latest
    entrypoint: [""]
  dependencies:
    - extract_module_info
  script:
    - set -ex  # Abilita debug e termina subito se un comando fallisce
    - if [ -f module_info.env ]; then . module_info.env; fi
    - echo "DEBUG Branch = $CI_COMMIT_REF_NAME"
    - echo "DEBUG MODULE_NAME = $MODULE_NAME"
    - echo "DEBUG VERSION = $VERSION"

    # Se siamo su main, vietiamo SNAPSHOT e versioni già esistenti
    - |
      if [[ "$CI_COMMIT_REF_NAME" == "main" ]]; then
        if [[ "$VERSION" == *"SNAPSHOT"* ]]; then
          echo "Versione $VERSION non valida (SNAPSHOT) su main!"
          exit 1
        fi

        # Facoltativo: controlliamo se la versione esiste già su S3
        # NOTA: questa riga fallirà se credenziali o bucket non sono impostati correttamente.
        FOUND=$(aws s3 ls "s3://${S3_BUCKET_NAME}/${MODULE_NAME}/${VERSION}/" | wc -l)
        if [ "$FOUND" -gt 0 ]; then
          echo "La versione $VERSION esiste già su S3! Interrompo la pipeline."
          exit 1
        fi
      fi
  # Se vuoi eseguire la pipeline solo su main, aggiungi qui `only: [main]`
  # Se vuoi eseguirla anche su develop, lascialo così

test_project:
  stage: test
  script:
    - set -x
    - echo "Esecuzione test / validazioni..."
    - echo "Ad esempio, puoi controllare sintassi di file .yml, .properties, ecc."
  needs:
    - extract_module_info
    - check_version
  only:
    - develop
    - main

package_configs:
  stage: package
  script:
    - set -x
    - if [ -f module_info.env ]; then . module_info.env; fi
    - echo "Creazione pacchetto di configurazione $MODULE_NAME versione $VERSION..."
    - apk add --no-cache zip
    - mkdir -p dist
    - zip -r "dist/$MODULE_NAME-$VERSION.zip" aws/ docker/ scripts/ env/ *.yml *.yaml *.properties || echo "Nessun file da includere"
    - echo "{\"moduleName\":\"$MODULE_NAME\",\"version\":\"$VERSION\",\"buildDate\":\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",\"branch\":\"$CI_COMMIT_REF_NAME\",\"commitHash\":\"$CI_COMMIT_SHA\"}" > dist/manifest.json
  dependencies:
    - extract_module_info
    - check_version
  artifacts:
    paths:
      - dist/
  only:
    - develop
    - main

upload_to_s3:
  stage: upload
  image:
    name: amazon/aws-cli:latest
    entrypoint: [""]
  dependencies:
    - package_configs
    - extract_module_info
    - check_version
  script:
    - set -x
    - if [ -f module_info.env ]; then . module_info.env; fi
    - echo "DEBUG MODULE_NAME=$MODULE_NAME, VERSION=$VERSION"
    - aws configure set region "${AWS_DEFAULT_REGION}"
    - echo "Caricamento su S3 in s3://${S3_BUCKET_NAME}/${MODULE_NAME}/${VERSION}/"
    - aws s3 cp dist/ "s3://${S3_BUCKET_NAME}/${MODULE_NAME}/${VERSION}/" --recursive

    - echo "{\"latestVersion\":\"${VERSION}\",\"updateTime\":\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"}" > latest.json
    - aws s3 cp latest.json "s3://${S3_BUCKET_NAME}/${MODULE_NAME}/latest.json"

    # Mantieni max 5 versioni
    - LIST=$(aws s3 ls "s3://${S3_BUCKET_NAME}/${MODULE_NAME}/" | grep PRE | awk '{print $2}' | sed 's#/##' | sort -r)
    - COUNT=0
    - for ver in $LIST; do
      ((COUNT++))
      if [ $COUNT -gt 5 ]; then
      echo "Elimino versione più vecchia su S3 $ver"
      aws s3 rm "s3://${S3_BUCKET_NAME}/${MODULE_NAME}/$ver" --recursive
      fi
      done

    - echo "Caricamento completato!"
  only:
    - main
  environment:
    name: sit

deploy_to_sit:
  stage: deploy_configs
  image: alpine:latest
  dependencies:
    - extract_module_info
    - check_version
  before_script:
    - apk update && apk add --no-cache openssh-client bash
    - mkdir -p ~/.ssh
    - if [ -z "$EC2_HOST" ]; then echo "EC2_HOST non definito"; exit 1; fi
    - if [ -z "$EC2_PRIVATE_KEY" ]; then echo "EC2_PRIVATE_KEY non definito"; exit 1; fi
    - if [ -z "$EC2_USER" ]; then echo "EC2_USER non definito"; exit 1; fi
    - echo "$EC2_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/id_rsa
    - if [ ! -s ~/.ssh/id_rsa ]; then echo "La chiave privata SSH è vuota"; exit 1; fi
    - chmod 600 ~/.ssh/id_rsa
    - ssh-keyscan -H "$EC2_HOST" >> ~/.ssh/known_hosts || true
  script:
    - set -x
    - if [ -f module_info.env ]; then . module_info.env; fi
    - echo "Aggiornamento delle configurazioni sull'ambiente SIT..."
    - echo "#!/bin/bash" > update_configs.sh
    - echo "set -e" >> update_configs.sh
    - echo "cd ~/auxdromos" >> update_configs.sh
    - echo "git pull" >> update_configs.sh
    - echo "echo \"Configurazioni aggiornate con successo!\"" >> update_configs.sh
    - scp update_configs.sh "$EC2_USER@$EC2_HOST:/tmp/"
    - ssh -o StrictHostKeyChecking=no "$EC2_USER@$EC2_HOST" "bash /tmp/update_configs.sh"
    - echo "Configurazioni aggiornate su SIT con successo!"
  only:
    - main
  environment:
    name: sit
